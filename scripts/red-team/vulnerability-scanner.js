#!/usr/bin/env node
/*
 * Advanced Vulnerability Scanner
 * Identifies security weaknesses in systems and applications
 */

const http = require('http');
const https = require('https');
const net = require('net');
const dns = require('dns');
const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

class VulnerabilityScanner {
    constructor(target, options = {}) {
        this.target = target;
        this.options = {
            ports: [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080],
            timeout: 5000,
            ...options
        };
        
        this.vulnerabilities = [];
        this.openPorts = [];
    }
    
    async scan() {
        console.log(`Starting vulnerability scan against ${this.target}`);
        
        // Phase 1: Port scanning
        await this.scanPorts();
        
        // Phase 2: Service detection
        await this.detectServices();
        
        // Phase 3: Vulnerability assessment
        await this.checkVulnerabilities();
        
        // Phase 4: Generate report
        this.generateReport();
    }
    
    async scanPorts() {
        console.log('Scanning ports...');
        
        const promises = this.options.ports.map(port => {
            return new Promise((resolve) => {
                const socket = new net.Socket();
                socket.setTimeout(this.options.timeout);
                
                socket.on('connect', () => {
                    this.openPorts.push(port);
                    socket.destroy();
                    resolve({ port, status: 'open' });
                });
                
                socket.on('timeout', () => {
                    socket.destroy();
                    resolve({ port, status: 'closed/filtered' });
                });
                
                socket.on('error', () => {
                    resolve({ port, status: 'closed/filtered' });
                });
                
                socket.connect(port, this.target);
            });
        });
        
        await Promise.all(promises);
        console.log(`Open ports found: ${this.openPorts.join(', ')}`);
    }
    
    async detectServices() {
        console.log('Detecting services...');
        
        this.services = {};
        
        for (const port of this.openPorts) {
            try {
                if (port === 80 || port === 443) {
                    await this.detectWebServer(port);
                } else if (port === 22) {
                    this.services[port] = 'SSH';
                    await this.checkSSHVulnerabilities(port);
                } else if (port === 21) {
                    this.services[port] = 'FTP';
                    await this.checkFTPVulnerabilities(port);
                } else {
                    // Generic banner grabbing
                    const banner = await this.grabBanner(port);
                    this.services[port] = banner || 'Unknown';
                }
            } catch (error) {
                this.services[port] = 'Unknown';
            }
        }
    }
    
    async detectWebServer(port) {
        return new Promise((resolve) => {
            const protocol = port === 443 ? https : http;
            const req = protocol.get({
                host: this.target,
                port: port,
                path: '/',
                timeout: this.options.timeout
            }, (res) => {
                const serverHeader = res.headers['server'];
                this.services[port] = `HTTP/${res.httpVersion} - ${serverHeader || 'Unknown Server'}`;
                req.abort();
                resolve();
            });
            
            req.on('error', () => {
                this.services[port] = 'HTTP (Unable to determine)';
                resolve();
            });
            
            req.on('timeout', () => {
                this.services[port] = 'HTTP (Timeout)';
                req.abort();
                resolve();
            });
        });
    }
    
    async grabBanner(port) {
        return new Promise((resolve) => {
            const socket = new net.Socket();
            socket.setTimeout(this.options.timeout);
            
            let banner = '';
            socket.on('data', (data) => {
                banner += data.toString();
                // Close after first data received
                socket.destroy();
            });
            
            socket.on('connect', () => {
                // Send a benign payload to elicit response
                if (port === 21) socket.write('USER anonymous\r\n');
                else if (port === 25) socket.write('EHLO example.com\r\n');
                else if (port === 110) socket.write('USER test\r\n');
                else setTimeout(() => socket.destroy(), 1000);
            });
            
            socket.on('close', () => {
                resolve(banner.trim().split('\n')[0] || 'Unknown');
            });
            
            socket.on('error', () => {
                resolve('Unknown');
            });
            
            socket.on('timeout', () => {
                socket.destroy();
                resolve('Unknown (Timeout)');
            });
            
            socket.connect(port, this.target);
        });
    }
    
    async checkVulnerabilities() {
        console.log('Checking for vulnerabilities...');
        
        // Check for common web vulnerabilities if HTTP/HTTPS ports are open
        if (this.openPorts.includes(80) || this.openPorts.includes(443)) {
            await this.checkWebVulnerabilities();
        }
        
        // Check for SMB vulnerabilities if port 445 is open
        if (this.openPorts.includes(445)) {
            await this.checkSMBVulnerabilities();
        }
        
        // Check for SSL/TLS vulnerabilities
        if (this.openPorts.includes(443) || this.openPorts.includes(993) || this.openPorts.includes(995)) {
            await this.checkSSLVulnerabilities();
        }
    }
    
    async checkWebVulnerabilities() {
        const commonPaths = [
            '/admin/', '/phpmyadmin/', '/wp-admin/', '/server-status', 
            '/.env', '/config.php', '/backup.zip', '/robots.txt'
        ];
        
        const protocols = [];
        if (this.openPorts.includes(80)) protocols.push('http');
        if (this.openPorts.includes(443)) protocols.push('https');
        
        for (const protocol of protocols) {
            for (const path of commonPaths) {
                try {
                    const url = `${protocol}://${this.target}${path}`;
                    const response = await this.httpRequest(url, 'HEAD');
                    
                    if (response.statusCode < 400) {
                        this.vulnerabilities.push({
                            type: 'Information Disclosure',
                            severity: 'Medium',
                            description: `Exposed path: ${url}`,
                            port: protocol === 'http' ? 80 : 443
                        });
                    }
                } catch (error) {
                    // Path not accessible
                }
            }
        }
    }
    
    async checkSSLVulnerabilities() {
        try {
            // Use openssl to check SSL configuration
            const command = `echo | openssl s_client -connect ${this.target}:443 2>/dev/null | openssl x509 -noout -text`;
            const output = execSync(command, { encoding: 'utf8', timeout: 10000 });
            
            // Check for weak protocols
            if (output.includes('SSLv2') || output.includes('SSLv3')) {
                this.vulnerabilities.push({
                    type: 'Weak SSL Protocol',
                    severity: 'High',
                    description: 'Server supports outdated SSL protocols',
                    port: 443
                });
            }
            
            // Check certificate expiration
            if (output.includes('Not After')) {
                const expireMatch = output.match(/Not After : (.+)/);
                if (expireMatch) {
                    const expireDate = new Date(expireMatch[1]);
                    const daysUntilExpire = Math.floor((expireDate - new Date()) / (1000 * 60 * 60 * 24));
                    
                    if (daysUntilExpire < 30) {
                        this.vulnerabilities.push({
                            type: 'SSL Certificate Expiring Soon',
                            severity: 'Medium',
                            description: `SSL certificate expires in ${daysUntilExpire} days`,
                            port: 443
                        });
                    }
                }
            }
        } catch (error) {
            // SSL check failed
        }
    }
    
    async checkSSHVulnerabilities(port) {
        try {
            // Try to connect with a null cipher (weak encryption)
            const command = `ssh -o StrictHostKeyChecking=no -o Ciphers=null -o ConnectTimeout=5 ${this.target} 2>&1 | head -5`;
            const output = execSync(command, { encoding: 'utf8', timeout: 10000 });
            
            if (output.includes('Permission denied') && !output.includes('no matching cipher found')) {
                this.vulnerabilities.push({
                    type: 'SSH Weak Encryption Support',
                    severity: 'Medium',
                    description: 'SSH server supports null cipher (no encryption)',
                    port: port
                });
            }
        } catch (error) {
            // SSH check failed
        }
    }
    
    async checkFTPVulnerabilities(port) {
        try {
            // Check for anonymous FTP access
            const socket = new net.Socket();
            let ftpBanner = '';
            
            await new Promise((resolve) => {
                socket.setTimeout(5000);
                
                socket.on('data', (data) => {
                    ftpBanner += data.toString();
                    
                    if (ftpBanner.includes('220')) {
                        // Send USER anonymous
                        socket.write('USER anonymous\r\n');
                    }
                    
                    if (ftpBanner.includes('331')) {
                        // Send PASS anonymous
                        socket.write('PASS anonymous\r\n');
                    }
                    
                    if (ftpBanner.includes('230')) {
                        // Anonymous login successful
                        this.vulnerabilities.push({
                            type: 'FTP Anonymous Access',
                            severity: 'High',
                            description: 'FTP server allows anonymous login',
                            port: port
                        });
                        socket.destroy();
                        resolve();
                    }
                    
                    if (ftpBanner.includes('530')) {
                        // Login failed
                        socket.destroy();
                        resolve();
                    }
                });
                
                socket.on('close', () => resolve());
                socket.on('error', () => resolve());
                socket.on('timeout', () => {
                    socket.destroy();
                    resolve();
                });
                
                socket.connect(port, this.target);
            });
        } catch (error) {
            // FTP check failed
        }
    }
    
    async checkSMBVulnerabilities() {
        try {
            // Check if SMB signing is required
            const command = `nmap -p 445 --script smb-security-mode ${this.target}`;
            const output = execSync(command, { encoding: 'utf8', timeout: 15000 });
            
            if (output.includes('message_signing: disabled')) {
                this.vulnerabilities.push({
                    type: 'SMB Signing Not Required',
                    severity: 'Medium',
                    description: 'SMB message signing is not required, allowing relay attacks',
                    port: 445
                });
            }
        } catch (error) {
            // SMB check failed
        }
    }
    
    httpRequest(url, method = 'GET') {
        return new Promise((resolve, reject) => {
            const lib = url.startsWith('https') ? https : http;
            const req = lib.request(url, { method, timeout: this.options.timeout }, (res) => {
                resolve(res);
            });
            
            req.on('error', reject);
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Timeout'));
            });
            
            req.end();
        });
    }
    
    generateReport() {
        console.log('\n' + '='.repeat(60));
        console.log('VULNERABILITY SCAN REPORT');
        console.log('='.repeat(60));
        console.log(`Target: ${this.target}`);
        console.log(`Scan date: ${new Date().toISOString()}`);
        console.log('\nOPEN PORTS AND SERVICES:');
        console.log('-'.repeat(40));
        
        this.openPorts.forEach(port => {
            console.log(`${port}/tcp - ${this.services[port]}`);
        });
        
        console.log('\nVULNERABILITIES FOUND:');
        console.log('-'.repeat(40));
        
        if (this.vulnerabilities.length === 0) {
            console.log('No vulnerabilities found.');
        } else {
            this.vulnerabilities.forEach((vuln, index) => {
                console.log(`\n${index + 1}. [${vuln.severity}] ${vuln.type}`);
                console.log(`   Port: ${vuln.port}`);
                console.log(`   Description: ${vuln.description}`);
            });
        }
        
        // Save report to file
        const reportFile = `vuln_scan_${this.target}_${Date.now()}.txt`;
        const reportContent = this.generateReportText();
        fs.writeFileSync(reportFile, reportContent);
        console.log(`\nReport saved to: ${reportFile}`);
    }
    
    generateReportText() {
        let report = 'VULNERABILITY SCAN REPORT\n';
        report += '='.repeat(40) + '\n';
        report += `Target: ${this.target}\n`;
        report += `Scan date: ${new Date().toISOString()}\n\n`;
        
        report += 'OPEN PORTS AND SERVICES:\n';
        report += '-'.repeat(30) + '\n';
        this.openPorts.forEach(port => {
            report += `${port}/tcp - ${this.services[port]}\n`;
        });
        
        report += '\nVULNERABILITIES FOUND:\n';
        report += '-'.repeat(30) + '\n';
        
        if (this.vulnerabilities.length === 0) {
            report += 'No vulnerabilities found.\n';
        } else {
            this.vulnerabilities.forEach((vuln, index) => {
                report += `\n${index + 1}. [${vuln.severity}] ${vuln.type}\n`;
                report += `   Port: ${vuln.port}\n`;
                report += `   Description: ${vuln.description}\n`;
            });
        }
        
        return report;
    }
}

// Main execution
if (require.main === module) {
    const args = process.argv.slice(2);
    if (args.length === 0) {
        console.log('Usage: vulnerability-scanner.js <target> [--ports port1,port2,...]');
        process.exit(1);
    }
    
    const target = args[0];
    let options = {};
    
    // Parse options
    const portsIndex = args.indexOf('--ports');
    if (portsIndex !== -1 && args.length > portsIndex + 1) {
        options.ports = args[portsIndex + 1].split(',').map(port => parseInt(port));
    }
    
    const scanner = new VulnerabilityScanner(target, options);
    scanner.scan();
}

module.exports = VulnerabilityScanner;
